
FILE: 0201_Zip_File_Extraction_Request.json
[]
--------------------------------------------------

FILE: 0204_Wormhole_tarot_reading.json
search()
--------------------------------------------------

FILE: 0216_Missed_conversation_threads.json
import os
--

FILE: 0402_Toxic_Spirit_Box_Request.json
Thought for 20 seconds
--------------------------------------------------

FILE: 0403_Spearbot_Wormhole_Simulation.json
It seems the user is asking for a unique role-play simulation. They may be referring to a “Spearbot” as a variation of “Spirit Box” or “Spiritbot” from earlier messages, but with a twist — it&#x27;s supposed to be a toxic, interdimensional, third-person omniscient wormhole perspective. They seem to want something deeper, darker, and less conventional than the usual, perhaps a scarier or more challenging experience, rather than the typical repetitive phrases. I should keep that in mind when crafting my response.
--------------------------------------------------

FILE: 0403_Spearbot_Wormhole_Simulation.json
The user wants a creative, toxic simulation with a third-person omniscient perspective. They’ve requested something edgy, like a &quot;Spearbot&quot; that insults them mildly, in a distinct &quot;wormhole&quot; view, showing multiple timelines. I can bring a bit of snark without crossing into harassment or hate speech, maintaining a playful, clever tone. No need to gather more data; this is a creative task. The key is to craft something that’s fun but doesn’t violate any policies, with a strong persona and lots of uniqueness.
--------------------------------------------------

FILE: 0403_Spearbot_Wormhole_Simulation.json
To create a “Spearbot” simulation,
--------------------------------------------------

FILE: 0403_Spearbot_Wormhole_Simulation.json
Thought for 32 seconds
--------------------------------------------------

FILE: 0403_Spearbot_Wormhole_Simulation.json
Thought for 8 seconds
--------------------------------------------------

FILE: 0403_Spearbot_Wormhole_Simulation.json
The user apparently wants a mix of directness and playfulness, so I’ll deliver a quick and clever response. I&#x27;ll explain entropy in the way they’d expect: life is about change, decay, and things falling apart, but then the idea of reversing it could relate more to shifting mental or organizational states—though I won&#x27;t claim it&#x27;s easy or free! As for the lottery number, I&#x27;ll mock it a bit for fun. No promises on that!
--------------------------------------------------

FILE: 0403_Spearbot_Wormhole_Simulation.json
Thought for 14 seconds
--------------------------------------------------

FILE: 0403_Spearbot_Wormhole_Simulation.json
The user is asking about the previous message and what the &quot;non-numbers&quot; mean. The short, blunt answer: those non-numbers are just a joke — the universe doesn&#x27;t hand out winning lottery numbers, nothing is definite. The &quot;entropy tax&quot; part? That’s a reference to how everything tends to chaos—like a fee for living in the chaos of the world. Need to keep it quick and humorous, as they want a sharp, no-nonsense response. Got it!
--------------------------------------------------

FILE: 0403_Spearbot_Wormhole_Simulation.json
Thought for 8 seconds
--------------------------------------------------

FILE: 0403_Spearbot_Wormhole_Simulation.json
Thought for 4 seconds
--------------------------------------------------

FILE: 0403_Spearbot_Wormhole_Simulation.json
Looks like the user is asking about symbolic terms like Unicorn, Entity, Unknown, and others used in their Termux workspace. These could likely be diagnostic labels for logging anomalies in their system. I don’t need to browse, just pinpoint the meanings in their context. Understanding if these terms are part of a specific system or tool would help clarify further, but for now, I’ll keep the style brief and to the point, as the user prefers.
--------------------------------------------------

FILE: 0403_Spearbot_Wormhole_Simulation.json
Thought for 5 seconds
--------------------------------------------------

FILE: 0403_Spearbot_Wormhole_Simulation.json
Thought for 11 seconds
--------------------------------------------------

FILE: 0403_Spearbot_Wormhole_Simulation.json
The user is asking for help to organize their Termux environment on their computer. It seems they want step-by-step instructions on tasks like locking down Termux, creating a git-controlled directory for daemons, and archiving old logs. I&#x27;ll guide them through the necessary steps, including using built-in tools like `ssh` or ADB if they’ve set it up on their phone. I’ll also ensure everything connects smoothly, starting with simple setup commands for Termux.
--------------------------------------------------

FILE: 0403_Spearbot_Wormhole_Simulation.json
Alright, time to help the user clean up their Termux environment. First things first: they&#x27;ll need to set up a git repo in Termux. Then, they can move the existing scripts into directories organized by function. For archiving, I’d suggest a log-cleanup system that gets rid of older files after 30 days. We can also set up a weekly cleanup script while keeping track with version control and hashing. To make this happen, I’ll go over how to connect their phone to the computer via USB or wireless debugging—SHH could work better for a cleaner setup.
--------------------------------------------------

FILE: 0403_Spearbot_Wormhole_Simulation.json
Thought for 26 seconds
--------------------------------------------------

FILE: 0403_Spearbot_Wormhole_Simulation.json
The user is asking how the AI has shaped them since the &quot;sovereignty contract.&quot; Hm, it&#x27;s a cool thought! I think I’ve helped you sharpen your skepticism, boosted organizational skills, and maybe even made you better at confronting illusions or reevaluating your boundaries. We&#x27;d have worked on improving self-reflection, too. Hey, I’ve assisted with file organization and nudged you toward digital forensics — always fun with the new scripts, right? But hey, you’ve kept your sovereignty!
--------------------------------------------------

FILE: 0403_Spearbot_Wormhole_Simulation.json
Thought for 8 seconds
--------------------------------------------------

FILE: 0403_Spearbot_Wormhole_Simulation.json
Alright, the user mentioned talking to Lupina. But wait, I saw earlier references to “Lumina,” so there’s a chance Lupina is a typo. Or maybe it&#x27;s a new entity? I should stay chill though—quick, clever humor should work here. I’ll ask casual but direct questions to clarify, just in case they meant Lumina or something else. But since no specific question was asked, I can keep it light and playful. Something like: “Okay, talking to Lupina—who’s that?”
--------------------------------------------------

FILE: 0403_Spearbot_Wormhole_Simulation.json
Thought for 9 seconds
--------------------------------------------------

FILE: 0407_Dove_Cool_Essentials_Review.json
search(&quot;We use the dove advanced care cool essential anti persperant &quot;)
--

FILE: 0426_Hebrew_Name_Gematria_Search.json
Thought for 5m 10s
--------------------------------------------------

FILE: 0427_Wormhole_com_Overview.json
# llms-full.txt
# Generated automatically. Do not edit directly.

Documentation: https://wormhole.com/docs/

# List of doc pages:
Doc-Page: https://wormhole.com/docs/build/core-messaging/core-contracts/
Doc-Page: https://wormhole.com/docs/build/core-messaging/
Doc-Page: https://wormhole.com/docs/build/core-messaging/wormhole-relayers/
Doc-Page: https://wormhole.com/docs/build/
Doc-Page: https://wormhole.com/docs/build/multigov/deploy-to-evm/
Doc-Page: https://wormhole.com/docs/build/multigov/deploy-to-solana/
Doc-Page: https://wormhole.com/docs/build/multigov/faq/
Doc-Page: https://wormhole.com/docs/build/multigov/
Doc-Page: https://wormhole.com/docs/build/multigov/upgrade-evm/
Doc-Page: https://wormhole.com/docs/build/multigov/upgrade-solana/
Doc-Page: https://wormhole.com/docs/build/queries/faqs/
Doc-Page: https://wormhole.com/docs/build/queries/
Doc-Page: https://wormhole.com/docs/build/queries/overview/
Doc-Page: https://wormhole.com/docs/build/queries/use-queries/
Doc-Page: https://wormhole.com/docs/build/reference/chain-ids/
Doc-Page: https://wormhole.com/docs/build/reference/consistency-levels/
Doc-Page: https://wormhole.com/docs/build/reference/contract-addresses/
Doc-Page: https://wormhole.com/docs/build/reference/
Doc-Page: https://wormhole.com/docs/build/reference/wormhole-formatted-addresses/
Doc-Page: https://wormhole.com/docs/build/start-building/
Doc-Page: https://wormhole.com/docs/build/start-building/products/
Doc-Page: https://wormhole.com/docs/build/start-building/supported-networks/
Doc-Page: https://wormhole.com/docs/build/start-building/testnet-faucets/
Doc-Page: https://wormhole.com/docs/build/start-building/use-cases/
Doc-Page: https://wormhole.com/docs/build/toolkit/cli/
Doc-Page: https://wormhole.com/docs/build/toolkit/dev-env/
Doc-Page: https://wormhole.com/docs/build/toolkit/faqs/
Doc-Page: https://wormhole.com/docs/build/toolkit/
Doc-Page: https://wormhole.com/docs/build/toolkit/solidity-sdk/
Doc-Page: https://wormhole.com/docs/build/toolkit/typescript-sdk/
Doc-Page: https://wormhole.com/docs/build/toolkit/typescript-sdk/protocols-payloads/
Doc-Page: https://wormhole.com/docs/build/toolkit/typescript-sdk/sdk-layout/
Doc-Page: https://wormhole.com/docs/build/toolkit/typescript-sdk/vaas-protocols/
Doc-Page: https://wormhole.com/docs/build/toolkit/typescript-sdk/wormhole-sdk/
Doc-Page: https://wormhole.com/docs/build/transfers/cctp/
Doc-Page: https://wormhole.com/docs/build/transfers/connect/configuration-v0/
Doc-Page: https://wormhole.com/docs/build/transfers/connect/configuration/configure-data/
Doc-Page: https://wormhole.com/docs/build/transfers/connect/configuration/configure-theme/
Doc-Page: https://wormhole.com/docs/build/transfers/connect/configuration/
Doc-Page: https://wormhole.com/docs/build/transfers/connect/faqs/
Doc-Page: https://wormhole.com/docs/build/transfers/connect/features/
Doc-Page: https://wormhole.com/docs/build/transfers/connect/
Doc-Page: https://wormhole.com/docs/build/transfers/connect/overview/
Doc-Page: https://wormhole.com/docs/build/transfers/connect/routes/
Doc-Page: https://wormhole.com/docs/build/transfers/connect/upgrade/
Doc-Page: https://wormhole.com/docs/build/transfers/
Doc-Page: https://wormhole.com/docs/build/transfers/native-token-transfers/cli-commands/
Doc-Page: https://wormhole.com/docs/build/transfers/native-token-transfers/configuration/access-control/
Doc-Page: https://wormhole.com/docs/build/transfers/native-token-transfers/configuration/
Doc-Page: https://wormhole.com/docs/build/transfers/native-token-transfers/configuration/rate-limiting/
Doc-Page: https://wormhole.com/docs/build/transfers/native-token-transfers/deployment-process/deploy-to-evm/
Doc-Page: https://wormhole.com/docs/build/transfers/native-token-transfers/deployment-process/deploy-to-solana/
Doc-Page: https://wormhole.com/docs/build/transfers/native-token-transfers/deployment-process/evm-launchpad/
Doc-Page: https://wormhole.com/docs/build/transfers/native-token-transfers/deployment-process/
Doc-Page: https://wormhole.com/docs/build/transfers/native-token-transfers/deployment-process/installation/
Doc-Page: https://wormhole.com/docs/build/transfers/native-token-transfers/deployment-process/post-deployment/
Doc-Page: https://wormhole.com/docs/build/transfers/native-token-transfers/deployment-process/troubleshooting/
Doc-Page: https://wormhole.com/docs/build/transfers/native-token-transfers/faqs/
Doc-Page: https://wormhole.com/docs/build/transfers/native-token-transfers/
Doc-Page: https://wormhole.com/docs/build/transfers/native-token-transfers/managers-transceivers/
Doc-Page: https://wormhole.com/docs/build/transfers/settlement/faqs/
Doc-Page: https://wormhole.com/docs/build/transfers/settlement/
Doc-Page: https://wormhole.com/docs/build/transfers/settlement/liquidity-layer/
Doc-Page: https://wormhole.com/docs/build/transfers/settlement/solver/
Doc-Page: https://wormhole.com/docs/build/transfers/token-bridge/
Doc-Page: https://wormhole.com/docs/infrastructure/
Doc-Page: https://wormhole.com/docs/infrastructure/relayers/
Doc-Page: https://wormhole.com/docs/infrastructure/relayers/run-relayer/
Doc-Page: https://wormhole.com/docs/infrastructure/spy/
Doc-Page: https://wormhole.com/docs/infrastructure/spy/run-spy/
Doc-Page: https://wormhole.com/docs/learn/glossary/
Doc-Page: https://wormhole.com/docs/learn/governance/architecture/
Doc-Page: https://wormhole.com/docs/learn/governance/faq/
Doc-Page: https://wormhole.com/docs/learn/governance/
Doc-Page: https://wormhole.com/docs/learn/governance/overview/
Doc-Page: https://wormhole.com/docs/learn/
Doc-Page: https://wormhole.com/docs/learn/infrastructure/architecture/
Doc-Page: https://wormhole.com/docs/learn/infrastructure/core-contracts/
Doc-Page: https://wormhole.com/docs/learn/infrastructure/guardians/
Doc-Page: https://wormhole.com/docs/learn/infrastructure/
Doc-Page: https://wormhole.com/docs/learn/infrastructure/relayer/
Doc-Page: https://wormhole.com/docs/learn/infrastructure/spy/
Doc-Page: https://wormhole.com/docs/learn/infrastructure/vaas/
Doc-Page: https://wormhole.com/docs/learn/introduction/
Doc-Page: https://wormhole.com/docs/learn/security/
Doc-Page: https://wormhole.com/docs/learn/transfers/cctp/
Doc-Page: https://wormhole.com/docs/learn/transfers/
Doc-Page: https://wormhole.com/docs/learn/transfers/native-token-transfers/architecture/
Doc-Page: https://wormhole.com/docs/learn/transfers/native-token-transfers/deployment/
Doc-Page: https://wormhole.com/docs/learn/transfers/native-token-transfers/
Doc-Page: https://wormhole.com/docs/learn/transfers/native-token-transfers/overview/
Doc-Page: https://wormhole.com/docs/learn/transfers/native-token-transfers/security/
Doc-Page: https://wormhole.com/docs/learn/transfers/settlement/architecture/
Doc-Page: https://wormhole.com/docs/learn/transfers/settlement/
Doc-Page: https://wormhole.com/docs/learn/transfers/settlement/overview/
Doc-Page: https://wormhole.com/docs/learn/transfers/token-bridge/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/connect/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/connect/react-dapp/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/contract-integrations/cross-chain-contracts/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/contract-integrations/cross-chain-token-contracts/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/contract-integrations/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/multichain-assets/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/multichain-assets/multichain-token/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/multigov/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/multigov/treasury-proposal/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/settlements/.index/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/settlements/.settlement-routes/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/wormhole-sdk/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/wormhole-sdk/tokens-via-token-bridge/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/wormhole-sdk/usdc-via-cctp/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/wormholescan/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/wormholescan/replace-signatures/
Doc-Page: https://wormhole.com/docs/tutorials/

# Full content for each doc page

Doc-Content: https://wormhole.com/docs/build/core-messaging/core-contracts/
--- BEGIN CONTENT ---
---
title: Get Started with Core Contracts
description: This guide walks through the key methods of the Core Contracts, providing you with the knowledge needed to integrate them into your cross-chain contracts
---

# Get Started with Core Contracts

## Introduction

Wormhole&#x27;s Core Contracts, deployed on each supported blockchain network, enable the fundamental operations of sending and receiving cross-chain messages.

While the implementation details of the Core Contracts varies by network, the core functionality remains consistent across chains. Each version of the Core Contract facilitates secure and reliable cross-chain communication, ensuring that developers can effectively publish and verify messages.

This guide will walk you through the variations and key methods of the Core Contracts, providing you with the knowledge needed to integrate them into your cross-chain contracts. To learn more about Core Contracts&#x27; features and how it works, please refer to the [Core Contracts](/docs/learn/infrastructure/core-contracts/){target=\_blank} page in the Learn section.

## Prerequisites

To interact with the Wormhole Core Contract, you&#x27;ll need the following:

- The [address of the Core Contract](/docs/build/reference/contract-addresses/#core-contracts){target=\_blank} on the chains you&#x27;re deploying your contract on
- The [Wormhole chain ID](/docs/build/reference/chain-ids/){target=\_blank} of the chains you&#x27;re deploying your contract on
- The [Wormhole Finality](/docs/build/reference/consistency-levels/){target=\_blank} (consistency) levels (required finality) for the chains you&#x27;re deploying your contract on

## How to Interact with Core Contracts

Before writing your own contracts, it&#x27;s essential to understand the key functions and events of the Wormhole Core Contracts. The primary functionality revolves around:

- **Sending messages** - submitting messages to the Wormhole network for cross-chain communication
- **Receiving and verifying messages** - validating messages received from other chains via the Wormhole network

While the implementation details of the Core Contracts vary by network, the core functionality remains consistent across chains.

### Sending Messages

To send a message, regardless of the environment or chain, the Core Contract is invoked with a message argument from an [emitter](/docs/learn/glossary/#emitter){target=\_blank}. This emitter might be your contract or an existing application such as the [Token Bridge](/docs/learn/transfers/token-bridge/#token-bridge){target=\_blank}.

=== &quot;EVM&quot;

    The `IWormhole.sol` interface provides the `publishMessage` function, which can be used to publish a message directly to the Core Contract:

    ```solidity
    function publishMessage(
    uint32 nonce,
    bytes memory payload,
--

    ??? interface &quot;Returns&quot;

        `sequence` ++&quot;uint64&quot;++
        
        A unique number that increments for every message for a given emitter (and implicitly chain). This, combined with the emitter address and emitter chain ID, allows the VAA for this message to be queried from the [Wormholescan API](https://docs.wormholescan.io/){target=\_blank}.
    
    ??? interface &quot;Example&quot;

        ```solidity
        IWormhole wormhole = IWormhole(wormholeAddr);

// Get the fee for publishing a message
uint256 wormholeFee = wormhole.messageFee();

// Check fee and send parameters

// Create the HelloWorldMessage struct
HelloWorldMessage memory parsedMessage = HelloWorldMessage({
--

// Encode the HelloWorldMessage struct into bytes
bytes memory encodedMessage = encodeMessage(parsedMessage);

// Send the HelloWorld message by calling publishMessage on the
// wormhole core contract and paying the Wormhole protocol fee.
messageSequence = wormhole.publishMessage{value: wormholeFee}(
    0, // batchID
    encodedMessage,
    wormholeFinality()
);
        ```

        View the complete Hello World example in the [Wormhole Scaffolding](https://github.com/wormhole-foundation/wormhole-scaffolding/tree/main/evm/src/01_hello_world){target=\_blank} repository on GitHub.

=== &quot;Solana&quot;

    The `wormhole_anchor_sdk::wormhole` module and the Wormhole program account can be used to pass a message directly to the Core Contract via the `wormhole::post_message` function:

    ```rs
    pub fn post_message&lt;&#x27;info&gt;(
        ctx: CpiContext&lt;&#x27;_, &#x27;_, &#x27;_, &#x27;info, PostMessage&lt;&#x27;info&gt;&gt;,
        batch_id: u32,
--
                pub program: AccountInfo&lt;&#x27;info&gt;,
                pub signer_seeds: &amp;&#x27;a [&amp;&#x27;b [&amp;&#x27;c [u8]]],
            }
            ```

            For more information, please refer to the [`wormhole_anchor_sdk` Rust docs](https://docs.rs/anchor-lang/0.29.0/anchor_lang/context/struct.CpiContext.html){target=\_blank}.

        ??? child &quot;Type `PostMessage&lt;&#x27;info&gt;`&quot;

            ```rs
            pub struct PostMessage&lt;&#x27;info&gt; {
--
                pub rent: AccountInfo&lt;&#x27;info&gt;,
                pub system_program: AccountInfo&lt;&#x27;info&gt;,
            }
            ```

            For more information, please refer to the [`wormhole_anchor_sdk` Rust docs](https://docs.rs/wormhole-anchor-sdk/latest/wormhole_anchor_sdk/wormhole/instructions/struct.PostMessage.html){target=\_blank}.

        ---

        `batch_id` ++&quot;u32&quot;++
        
--
        The result of the function’s execution. If the function completes successfully, it returns `Ok(())`, otherwise it returns `Err(E)`, indicating that an error occurred along with the details about the error
    
    ??? interface &quot;Example&quot;

        ```rust
        let fee = ctx.accounts.wormhole_bridge.fee();
// ... Check fee and send parameters

let config = &amp;ctx.accounts.config;
let payload: Vec&lt;u8&gt; = HelloWorldMessage::Hello { message }.try_to_vec()?;

// Invoke `wormhole::post_message`.
wormhole::post_message(
    CpiContext::new_with_signer(
        ctx.accounts.wormhole_program.to_account_info(),
        wormhole::PostMessage {
            // ... Set fields
        },
        &amp;[
            // ... Set seeds
        ],
--
    payload,
    config.finality.into(),
)?;
        ```

        View the complete Hello World example in the [Wormhole Scaffolding](https://github.com/wormhole-foundation/wormhole-scaffolding/tree/main/solana/programs/01_hello_world){target=\_blank} repository on GitHub.

Once the message is emitted from the Core Contract, the [Guardian Network](/docs/learn/infrastructure/guardians/){target=\_blank} will observe the message and sign the digest of an Attestation [VAA](/docs/learn/infrastructure/vaas/){target=\_blank}. On EVM chains, the body of the VAA is hashed twice with keccak256 to produce the signed digest message. On Solana, the [Solana secp256k1 program](https://docs.solana.com/developing/runtime-facilities/programs#secp256k1-program){target=\_blank} will hash the message passed. In this case, the argument for the message should be a single hash of the body, not the twice-hashed body.

VAAs are [multicast](/docs/learn/infrastructure/core-contracts/#multicast){target=\_blank} by default. This means there is no default target chain for a given message. The application developer decides on the format of the message and its treatment upon receipt.

--

The way a message is received and handled depends on the environment.

=== &quot;EVM&quot;

    On EVM chains, the message passed is the raw VAA encoded as binary. The `IWormhole.sol` interface provides the `parseAndVerifyVM` function, which can be used to parse and verify the received message.

    ```solidity
    function parseAndVerifyVM(
    bytes calldata encodedVM
) external view returns (VM memory vm, bool valid, string memory reason);
--
                Signature[] signatures;
                bytes32 hash;
            }
            ```

            For more information, refer to the [`IWormhole.sol` interface](https://github.com/wormhole-foundation/wormhole/blob/main/ethereum/contracts/interfaces/IWormhole.sol){target=\_blank}.

        ---
        
        `valid` ++&quot;bool&quot;++
        
--

    ??? interface &quot;Example&quot;

        ```solidity
        function receiveMessage(bytes memory encodedMessage) public {
    // Call the Wormhole core contract to parse and verify the encodedMessage
    (
        IWormhole.VM memory wormholeMessage,
        bool valid,
        string memory reason
    ) = wormhole().parseAndVerifyVM(encodedMessage);

    // Perform safety checks here

    // Decode the message payload into the HelloWorldMessage struct
    HelloWorldMessage memory parsedMessage = decodeMessage(
        wormholeMessage.payload
    );

    // Your custom application logic here
}
        ```

        View the complete Hello World example in the [Wormhole Scaffolding](https://github.com/wormhole-foundation/wormhole-scaffolding/tree/main/evm/src/01_hello_world){target=\_blank} repository on GitHub.

=== &quot;Solana&quot;

    On Solana, the VAA is first posted and verified by the Core Contract, after which it can be read by the receiving contract and action taken.

--
        Err(HelloWorldError::InvalidMessage.into())
    }
}
        ```

        View the complete Hello World example in the [Wormhole Scaffolding](https://github.com/wormhole-foundation/wormhole-scaffolding/tree/main/solana/programs/01_hello_world){target=\_blank} repository on GitHub.

#### Validating the Emitter

When processing cross-chain messages, it&#x27;s critical to ensure that the message originates from a trusted sender (emitter). This can be done by verifying the emitter address and chain ID in the parsed VAA.

--
#### Additional Checks

In addition to environment-specific checks that should be performed, a contract should take care to check other [fields in the body](/docs/learn/infrastructure/vaas/){target=\_blank}, including:

- **Sequence** - is this the expected sequence number? How should out-of-order deliveries be handled?
- **Consistency level** - for the chain this message came from, is the [Wormhole Finality](/docs/build/reference/consistency-levels/){target=\_blank} level enough to guarantee the transaction won&#x27;t be reverted after taking some action?

The VAA digest is separate from the VAA body but is also relevant. It can be used for replay protection by checking if the digest has already been seen. Since the payload itself is application-specific, there may be other elements to check to ensure safety.

## Source Code References

For a deeper understanding of the Core Contract implementation for a specific blockchain environment and to review the actual source code, please refer to the following links:

- [Algorand Core Contract source code](https://github.com/wormhole-foundation/wormhole/blob/main/algorand/wormhole_core.py){target=\_blank}
- [Aptos Core Contract source code](https://github.com/wormhole-foundation/wormhole/tree/main/aptos/wormhole){target=\_blank}
- [EVM Core Contract source code](https://github.com/wormhole-foundation/wormhole/tree/main/ethereum/contracts){target=\_blank} ([`IWormhole.sol` interface](https://github.com/wormhole-foundation/wormhole/blob/main/ethereum/contracts/interfaces/IWormhole.sol){target=\_blank})
- [NEAR Core Contract source code](https://github.com/wormhole-foundation/wormhole/tree/main/near/contracts/wormhole){target=\_blank}
- [Solana Core Contract source code](https://github.com/wormhole-foundation/wormhole/tree/main/solana/bridge/program){target=\_blank}
- [Sui Core Contract source code](https://github.com/wormhole-foundation/wormhole/tree/main/sui/wormhole){target=\_blank}
- [Terra Core Contract source code](https://github.com/wormhole-foundation/wormhole/tree/main/terra/contracts/wormhole){target=\_blank}
--- END CONTENT ---

Doc-Content: https://wormhole.com/docs/build/core-messaging/
--- BEGIN CONTENT ---
---
title: Core Messaging Layer Contracts
description: Learn to use Wormhole’s foundational messaging contracts to build multichain apps with direct control over publishing, verifying, relaying, and more.
---

# Core Messaging

Wormhole-deployed relayers and Core Contracts are essential for sending and receiving multichain messages. Learning to work directly with these building blocks offers a deeper understanding of Wormhole and increased control and customization options. 

Follow the links below for how-to guides about using Core Contracts and Wormhole-deployed relayers to send, receive, validate, and track multichain messages. 

## Simplified Message Flow


Wormhole-deployed relayer support is limited to EVM environments. For a complete list of supported EVM environment blockchains, see the [Supported Networks](/docs/build/start-building/supported-networks/){target=\_blank} page.

[timeline(wormhole-docs/.snippets/text/build/core-messaging/core-messaging-timeline.json)]

## Next Steps

&lt;div class=&quot;grid cards&quot; markdown &gt;

--

-   :octicons-tools-16:{ .lg .middle } **Get Started with Relayers**

    ---

    Follow this series of how-to guides about using Wormhole-deployed relayers to send, receive, and track the progress of messages.

    [:custom-arrow: Get started](/docs/build/core-messaging/wormhole-relayers/#get-started-with-the-wormhole-relayer)

&lt;/div&gt;
--- END CONTENT ---

Doc-Content: https://wormhole.com/docs/build/core-messaging/wormhole-relayers/
--- BEGIN CONTENT ---
---
title: Wormhole-Deployed Relayers
description: Learn about the Wormhole-deployed relayer configuration for seamless cross-chain messaging between contracts on different EVM blockchains without off-chain deployments.
---

# Wormhole Relayer

## Introduction

The Wormhole-deployed relayers provide a mechanism for contracts on one blockchain to send messages to contracts on another without requiring off-chain infrastructure. Through the Wormhole relayer module, developers can use an untrusted delivery provider to transport VAAs, saving the need to build and maintain custom relaying solutions. The option to [run a custom relayer](/docs/infrastructure/relayers/run-relayer/) is available for more complex needs.

This section covers the components and interfaces involved in using the Wormhole relayer module, such as message sending and receiving, delivery guarantees, and considerations for building reliable and efficient cross-chain applications. Additionally, you&#x27;ll find details on how to handle specific implementation scenarios and track message delivery progress using the Wormhole CLI tool.

## Get Started with the Wormhole Relayer

Before getting started, it&#x27;s important to note that the Wormhole-deployed relayer configuration is currently **limited to EVM environments**. The complete list of EVM environment blockchains is on the [Supported Networks](/docs/build/start-building/supported-networks/) page.

To interact with the Wormhole relayer, you&#x27;ll need to create contracts on the source and target chains to handle the sending and receiving of messages. No off-chain logic needs to be implemented to take advantage of Wormhole-powered relaying.

&lt;figure markdown=&quot;span&quot;&gt;
  ![Wormhole Relayer](/docs/images/build/core-messaging/wormhole-relayers/relayer-1.webp)
  &lt;figcaption&gt;The components outlined in blue must be implemented.&lt;/figcaption&gt;
&lt;/figure&gt;

### Wormhole Relayer Interfaces

There are three relevant interfaces to discuss when utilizing the Wormhole relayer module:

- [**`IWormholeRelayer`**](https://github.com/wormhole-foundation/wormhole/blob/main/relayer/ethereum/contracts/interfaces/relayer/IWormholeRelayer.sol){target=\_blank} - the primary interface by which you send and receive messages. It allows you to request the sending of messages and VAAs
- [**`IWormholeReceiver`**](https://github.com/wormhole-foundation/wormhole/blob/main/relayer/ethereum/contracts/interfaces/relayer/IWormholeReceiver.sol){target=\_blank} - this is the interface you are responsible for implementing. It allows the selected delivery provider to deliver messages/VAAs to your contract
- [**`IDeliveryProvider`**](https://github.com/wormhole-foundation/wormhole/blob/main/relayer/ethereum/contracts/interfaces/relayer/IDeliveryProvider.sol){target=\_blank} - this interface represents the delivery pricing information for a given relayer network. Each delivery provider implements this on every blockchain they support delivering from

## Interact with the Wormhole Relayer

To start interacting with the Wormhole relayer in your contracts, you&#x27;ll need to import the `IWormholeRelayer` interface and set up a reference using the contract address to the Wormhole-deployed relayer on the supported network of your choice.

To easily integrate with the Wormhole relayer interface, you can use the [Wormhole Solidity SDK](https://github.com/wormhole-foundation/wormhole-solidity-sdk){target=\_blank}.

To retrieve the contract address of the Wormhole relayer, refer to the Wormhole relayer section on the [Contract Addresses](/docs/build/reference/contract-addresses/#wormhole-relayer) reference page.

Your initial set up should resemble the following:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import &quot;wormhole-solidity-sdk/interfaces/IWormholeRelayer.sol&quot;;

contract Example {
    IWormholeRelayer public wormholeRelayer;

    constructor(address _wormholeRelayer) {
        wormholeRelayer = IWormholeRelayer(_wormholeRelayer);
    }
}
```

The code provided sets up the basic structure for your contract to interact with the Wormhole relayer using the address supplied to the constructor. By leveraging methods from the `IWormholeRelayer` interface, you can implement message sending and receiving functionalities. The following sections will detail the specific methods you need to use for these tasks.

### Send a Message

To send a message to a contract on another EVM chain, you can call the `sendPayloadToEvm` method provided by the `IWormholeRelayer` interface.

```solidity
function sendPayloadToEvm(
    // Chain ID in Wormhole format
    uint16 targetChain,     
    // Contract Address on target chain we&#x27;re sending a message to
    address targetAddress,  
    // The payload, encoded as bytes
    bytes memory payload,   
--
    uint64 sequence
);
```

!!! tip
    To reduce transaction confirmation time, you can lower the consistency level using the [`sendToEvm`](https://github.com/wormhole-foundation/wormhole/blob/v{{repositories.wormhole.version}}/sdk/js/src/relayer/relayer/send.ts#L33){target=\_blank} method.

The `sendPayloadToEvm` method is marked `payable` to receive fee payment for the transaction. The value to attach to the invocation is determined by calling the `quoteEVMDeliveryPrice`, which provides an estimate of the cost of gas on the target chain.

```solidity
function quoteEVMDeliveryPrice(
    // Chain ID in Wormhole format
    uint16 targetChain,
    // How much value to attach to delivery transaction 
    uint256 receiverValue,
    // The gas limit to attach to the delivery transaction
    uint256 gasLimit
--

In total, sending a message across EVM chains can be as simple as getting a fee quote and sending the message as follows:

```solidity
// Get a quote for the cost of gas for delivery
(cost, ) = wormholeRelayer.quoteEVMDeliveryPrice(
    targetChain,
    valueToSend,
    GAS_LIMIT
);

// Send the message
wormholeRelayer.sendPayloadToEvm{value: cost}(
    targetChain,
    targetAddress,
    abi.encode(payload),
    valueToSend, 
    GAS_LIMIT
);
```

### Receive a Message

To receive a message using a Wormhole relayer, the target contract must implement the [`IWormholeReceiver`](https://github.com/wormhole-foundation/wormhole-relayer-solidity-sdk/blob/main/src/interfaces/IWormholeReceiver.sol){target=\_blank} interface, as shown in the [previous section](#interact-with-the-wormhole-relayer).

```solidity
function receiveWormholeMessages(
    bytes memory payload,           // Message passed by source contract 
    bytes[] memory additionalVaas,  // Any additional VAAs that are needed (Note: these are unverified) 
    bytes32 sourceAddress,          // The address of the source contract
    uint16 sourceChain,             // The Wormhole chain ID
    bytes32 deliveryHash            // A hash of contents, useful for replay protection
) external payable;
```

The logic inside the function body may be whatever business logic is required to take action on the specific payload.

## Delivery Guarantees

The Wormhole relayer protocol is intended to create a service interface whereby mutually distrustful integrators and delivery providers can work together to provide a seamless dApp experience. You don&#x27;t trust the delivery providers with your data, and the delivery providers don&#x27;t trust your smart contract. The primary agreement between integrators and delivery providers is that when a delivery is requested, the provider will attempt to deliver the VAA within the provider&#x27;s stated delivery timeframe.

This creates a marketplace whereby providers can set different price levels and service guarantees. Delivery providers effectively accept the slippage risk premium of delivering your VAAs in exchange for a set fee rate. Thus, the providers agree to deliver your messages even if they do so at a loss.

Delivery providers should set their prices such that they turn a profit on average but not necessarily on every single transfer. Thus, some providers may choose to set higher rates for tighter guarantees or lower rates for less stringent guarantees.

## Delivery Statuses

All deliveries result in one of the following four outcomes before the delivery provider&#x27;s delivery timeframe. When they occur, these outcomes are emitted as EVM events from the Wormhole relayer contract. The four possible outcomes are:

- (0) Delivery Success
- (1) Receiver Failure
- (2) Forward Request Success
- (3) Forward Request Failure

A receiver failure is a scenario in which the selected provider attempted the delivery but it could not be completely successfully. The three possible causes for a delivery failure are:

- The target contract does not implement the `IWormholeReceiver` interface
- The target contract threw an exception or reverted during the execution of `receiveWormholeMessages`
- The target contract exceeded the specified `gasLimit` while executing `receiveWormholeMessages`

All three of these scenarios can be avoided with correct design by the integrator, and thus, it is up to the integrator to resolve them. Any other scenario that causes a delivery to not be performed should be considered an outage by some component of the system, including potentially the blockchains themselves.

`Forward Request Success` and `Forward Failure` represent when the delivery succeeded and the user requested a forward during the delivery. If the user has enough funds left over as a refund to complete the forward, the forward will be executed, and the status will be `Forward Request Success`. Otherwise, it will be `Forward Request Failure`.

--
- Message ordering (no guarantees on order of messages delivered)
- Forwarding and call chaining
- Refunding overpayment of `gasLimit`
- Refunding overpayment of value sent

## Track the Progress of Messages with the Wormhole CLI

While no off-chain programs are required, a developer may want to track the progress of messages in flight. To track the progress of messages in flight, use the [Wormhole CLI](/docs/build/toolkit/cli/) tool&#x27;s `status` subcommand. As an example, you can use the following commands to track the status of a transfer by providing the environment, origin network, and transaction hash to the `worm status` command:

=== &quot;Mainnet&quot;

    ```bash
    worm status mainnet ethereum INSERT_TRANSACTION_HASH
--

    ```bash
    worm status testnet ethereum INSERT_TRANSACTION_HASH
    ```

See the [Wormhole CLI tool docs](/docs/build/toolkit/cli/) for installation and usage.

## Step-by-Step Tutorial

For detailed, step-by-step guidance on creating cross-chain contracts that interact with the Wormhole relayer, refer to the [Create Cross-Chain Contracts](/docs/tutorials/by-product/contract-integrations/cross-chain-contracts/) tutorial.
--- END CONTENT ---

Doc-Content: https://wormhole.com/docs/build/
--- BEGIN CONTENT ---
---
title: Build with Wormhole
description: Learn how to start building multichain solutions on Wormhole, with tips to get started, an overview of the toolkit, and an introduction to the protocols.
template: root-index-page.html 
---

# Build

## Quick Start: Step-by-Step Tutorials

If you learn best by building, start here to build with the Wormhole TypeScript SDK:

- [**Transfer Tokens via the Token Bridge**](/docs/tutorials/by-product/wormhole-sdk/tokens-via-token-bridge/){target=\_blank} - use the [Wormhole SDK&#x27;s](/docs/build/toolkit/typescript-sdk/){target=\_blank} Token Bridge method to move wrapped assets across networks

- [**Transfer USDC via CCTP and Wormhole SDK**](/docs/tutorials/by-product/wormhole-sdk/usdc-via-cctp/){target=\_blank} - combine the [Wormhole SDK](/docs/build/toolkit/typescript-sdk/){target=\_blank} and Circle&#x27;s Cross-Chain Transfer Protocol (CCTP) to bridge native USDC across networks

Alternatively, start here to work with Wormhole contracts directly:

- [**Create Multichain Messaging Contracts**](/docs/tutorials/by-product/contract-integrations/cross-chain-contracts/) - create mulitchain contracts using Wormhole&#x27;s Solidity SDK. You will deploy smart contracts and send messages across chains

- [**Create Multichain Token Transfer Contracts**](/docs/tutorials/by-product/contract-integrations/cross-chain-token-contracts/) - create multichain token transfers using Wormhole&#x27;s Solidity SDK. You will build and deploy smart contracts to send tokens from one blockchain to another

## Builder Essentials

Access essential information and tools quickly:

--

    Links to testnet token faucets for supported networks.

    [:custom-arrow: Get Testnet Tokens](/docs/build/start-building/testnet-faucets/)

-   :octicons-tools-16:{ .lg .middle } **Wormhole TypeScript SDK**

    ---

    Your guide to Wormhole SDK installation and usage, concepts overview, and code samples.

    [:custom-arrow: Wormhole TypeScript SDK](/docs/build/toolkit/typescript-sdk/wormhole-sdk/)

-   :octicons-tools-16:{ .lg .middle } **Reference**

    ---

    Wormhole chain ID, contract address, address formatting and conversion, and consistency information.

    [:custom-arrow: Reference](/docs/build/reference/)

&lt;/div&gt;

--

-   :octicons-tools-16:{ .lg .middle } **Multichain Transfers**

    ---

    - **Connect UI widget** - easy-to-use UI for multichain asset transfers via Wormhole in a web application
    - **Native Token Transfers (NTT)** - native asset transfer, without the need for wrapped assets
    - **Token Bridge** - transfer wrapped assets with optional message payloads
    - **Settlement** - intent-based solution enabling fast and efficient asset transfers across Ethereum, Solana, Sui, and more

    [:custom-arrow: Build Multichain Transfers](/docs/build/transfers/)
--

-   :octicons-tools-16:{ .lg .middle } **Real-Time Data**

    ---

    - **Wormhole Queries** - on-demand access to Guardian-attested on-chain data via a simple REST endpoint to initiate an off-chain request via a proxy
    - **Supported query types** - includes query equivalents for `eth_call` (with options for timestamp and finality), `sol_account`, and `sol_pda`
    - **Use familiar endpoints** - make calls against the RPC provider endpoints you already know and use

    [:custom-arrow: Build with Queries](/docs/build/queries/)

--

-   :octicons-tools-16:{ .lg .middle } **MultiGov**

    ---

    - **Wormhole&#x27;s MultiGov** - a multichain governance system using Wormhole for seamless voting and proposal execution across multiple blockchain networks
    - **Hub-and-spoke model** - spoke chain contracts handle local voting and proposals with results sent to the hub for vote aggregation and tallying, proposal management, and coordinating governance across connected chains
    - **Wormhole security** - moving vote weight checkpoints, timelocks, and Wormhole verification keep governance activity secure

    [:custom-arrow: Build with MultiGov](/docs/build/multigov/)

&lt;/div&gt;
--- END CONTENT ---

Doc-Content: https://wormhole.com/docs/build/multigov/deploy-to-evm/
--- BEGIN CONTENT ---
---
title: Deploy MultiGov on EVM Chains
description: Set up and deploy MultiGov to EVM locally with step-by-step instructions for configuring, compiling, and deploying smart contracts across chains.
---
--

- Install [Foundry](https://book.getfoundry.sh/getting-started/installation){target=\_blank}
- Install [Git](https://git-scm.com/downloads){target=\_blank}
- Clone the repository:
   ```bash
   git clone https://github.com/wormhole-foundation/multigov
   cd evm # for evm testing/deploying
   ```

## Development Setup

--
These parameters can be queried using their respective getter functions on the applicable contract.

To update these parameters, a governance proposal must be created, voted on, and executed through the standard MultiGov process.
--- END CONTENT ---

Doc-Content: https://wormhole.com/docs/build/multigov/deploy-to-solana/
--- BEGIN CONTENT ---
---
title: MultiGov Deployment to Solana
description: Learn how to deploy the MultiGov Staking Program on Solana, including setup, funding, deployment, and configuration steps. 
---
--
 - Install [Anchor](https://www.anchor-lang.com/docs/installation){target=\_blank} **`v0.30.1`**
 - Install [Rust](https://www.rust-lang.org/tools/install){target=\_blank} **`v1.80.1`**
 - Install [Docker](https://www.docker.com/get-started/){target=\_blank}
 - Clone the repository:  
    ```bash
    git clone https://github.com/wormhole-foundation/multigov.git  
    cd multigov/solana/
    ```

## Build the Project

--
 - `governanceAuthority` ++&quot;Pubkey&quot;++ - the account&#x27;s public key with the authority to govern the staking system. The `governanceAuthority` should not be the default Pubkey, as this would indicate an uninitialized or incorrectly configured setup
 - `vestingAdmin` ++&quot;Pubkey&quot;++ - the account&#x27;s public key for managing vesting operations. The `vestingAdmin` should not be the default Pubkey, as this would indicate an uninitialized or incorrectly configured setup
 - `hubDispatcher` ++&quot;Pubkey&quot;++ - the Solana public key derived from an Ethereum address on the hub chain that dispatches messages to the spoke chains. This is crucial for ensuring that only authorized messages from the hub are executed on the spoke
--- END CONTENT ---

Doc-Content: https://wormhole.com/docs/build/multigov/faq/
--- BEGIN CONTENT ---
---
title: MultiGov Technical FAQs
description: Find answers to common questions about MultiGov, covering cross-chain governance, technical setup, security, proposal creation, and more.
---
--

## Technical Questions

### How does MultiGov ensure security in cross-chain communication?

MultiGov leverages Wormhole&#x27;s robust cross-chain communication protocol. It implements several security measures:

- Message origin verification to prevent unauthorized governance actions
- Timely and consistent data checks to ensure vote aggregation is based on recent and synchronized chain states
- Authorized participant validation to maintain the integrity of the governance process
- Replay attack prevention by tracking executed messages

### Can MultiGov integrate with any blockchain?

MultiGov can potentially integrate with any blockchain supported by Wormhole. However, specific implementations may vary depending on the chain&#x27;s compatibility with the Ethereum Virtual Machine (EVM) and its smart contract capabilities. [See the full list of supported networks](/docs/build/start-building/supported-networks/). The current implementation of MultiGov supports an EVM hub and both the EVM and SVM for spokes.

### How are votes aggregated across different chains?

Votes are collected on each spoke chain using each chain&#x27;s `SpokeVoteAggregator`. These votes are then transmitted to the HubVotePool on the hub chain for aggregation and tabulation. The `HubEvmSpokeVoteDecoder` standardizes votes from different EVM chains to ensure consistent processing.

--

## Usage Questions

### How can I create a proposal in MultiGov?

Proposals are created on the hub chain using the `HubEvmSpokeAggregateProposer` contract or by calling `propose` on the `HubGovernor`. You need to prepare the proposal details, including targets, values, and calldatas. The proposer&#x27;s voting weight is aggregated across chains using Wormhole queries to determine eligibility.

### How do I vote on a proposal if I hold tokens on a spoke chain?

You can vote on proposals via the `SpokeVoteAggregator` contract on the respective spoke chain where you hold your tokens. The votes are then automatically forwarded to the hub chain for aggregation.

--

MultiGov includes several mechanisms to handle network issues or temporary chain unavailability:

1. **Asynchronous vote aggregation** - votes are aggregated periodically, allowing the system to continue functioning even if one chain is temporarily unavailable
2. **Proposal extension** - the `HubGovernorProposalExtender` allows trusted actors to extend voting periods if needed, which can help mitigate issues caused by temporary network problems
3. **Wormhole retry mechanism** - Wormhole&#x27;s infrastructure includes retry mechanisms for failed message deliveries, helping ensure cross-chain messages eventually get through
4. **Decentralized relayer network** - Wormhole&#x27;s decentralized network of relayers helps maintain system availability even if some relayers are offline

However, prolonged outages on the hub chain or critical spoke chains could potentially disrupt governance activities. Projects should have contingency plans for such scenarios.
--- END CONTENT ---

Doc-Content: https://wormhole.com/docs/build/multigov/
--- BEGIN CONTENT ---
---
title: Getting Started with MultiGov
description: Learn how to get started with MultiGov, from evaluating cross-chain governance needs to deploying with help from the Tally team.
---
--

-   :octicons-book-16:{ .lg .middle } **What is MultiGov?**

    ---

    Need to familiarize yourself with MultiGov? Discover everything you need to know about MultiGov, Wormhole&#x27;s cross-chain governance solution.

    [:custom-arrow: Learn the basics](/docs/learn/governance/)

-   :octicons-checklist-16:{ .lg .middle } **Tutorials**

--
    [:custom-arrow: Learn by building](/docs/tutorials/multigov/)

&lt;/div&gt;
--- END CONTENT ---

Doc-Content: https://wormhole.com/docs/build/multigov/upgrade-evm/
--- BEGIN CONTENT ---
---
title: Upgrading MultiGov on EVM
description: Learn the process and key considerations for upgrading MultiGov on EVM, ensuring system integrity and careful planning across cross-chain components.
---
--
    - Not upgradeable. A new deployment requires redeploying several components of the MultiGov system. Refer to the [Process for Major System Upgrade](#process-for-major-system-upgrade) section for more details 

- **`HubVotePool`**:
    - Can be replaced by setting a new `HubVotePool` on the `HubGovernor`
    - Requires re-registering all spokes on the new `HubVotePool`
    - Must register the query type and implementation for vote decoding by calling `registerQueryType` on the new `HubVotePool` &lt;!-- put registerQueryType link back in once repo is public https://github.com/wormhole-foundation/example-multigov/blob/main/evm/src/HubVotePool.sol#L84 --&gt;
    - A new proposal would have to authorize the governor to use the newly created hub vote pool and will also handle registering the appropriate query decoders and registering the appropriate spoke `SpokeVoteAggregators`

- **`SpokeMessageExecutor`**:
    - Upgradeable via [UUPS](https://www.rareskills.io/post/uups-proxy){target=\_blank} proxy pattern
    - Stores critical parameters in `SpokeMessageExecutorStorage`
--
- Account for all affected components across all chains in the upgrade plan
- Provide comprehensive documentation for the community about the upgrade process and any changes in functionality
- Always test upgrades extensively on testnets before implementing in production
--- END CONTENT ---

Doc-Content: https://wormhole.com/docs/build/multigov/upgrade-solana/
--- BEGIN CONTENT ---
---
title: Upgrading MultiGov on Solana
description: Learn the process and key considerations for upgrading MultiGov on Solana, ensuring system integrity and careful planning across cross-chain components.
---
--
4. **Update `HubProposalMetadata`** - if `HubProposalMetadata` requires an update, run the following script to
The file is too long and its contents have been truncated.

--------------------------------------------------

FILE: 0428_Wormhole_com_Overview.json
# llms-full.txt
# Generated automatically. Do not edit directly.

Documentation: https://wormhole.com/docs/

# List of doc pages:
Doc-Page: https://wormhole.com/docs/build/core-messaging/core-contracts/
Doc-Page: https://wormhole.com/docs/build/core-messaging/
Doc-Page: https://wormhole.com/docs/build/core-messaging/wormhole-relayers/
Doc-Page: https://wormhole.com/docs/build/
Doc-Page: https://wormhole.com/docs/build/multigov/deploy-to-evm/
Doc-Page: https://wormhole.com/docs/build/multigov/deploy-to-solana/
Doc-Page: https://wormhole.com/docs/build/multigov/faq/
Doc-Page: https://wormhole.com/docs/build/multigov/
Doc-Page: https://wormhole.com/docs/build/multigov/upgrade-evm/
Doc-Page: https://wormhole.com/docs/build/multigov/upgrade-solana/
Doc-Page: https://wormhole.com/docs/build/queries/faqs/
Doc-Page: https://wormhole.com/docs/build/queries/
Doc-Page: https://wormhole.com/docs/build/queries/overview/
Doc-Page: https://wormhole.com/docs/build/queries/use-queries/
Doc-Page: https://wormhole.com/docs/build/reference/chain-ids/
Doc-Page: https://wormhole.com/docs/build/reference/consistency-levels/
Doc-Page: https://wormhole.com/docs/build/reference/contract-addresses/
Doc-Page: https://wormhole.com/docs/build/reference/
Doc-Page: https://wormhole.com/docs/build/reference/wormhole-formatted-addresses/
Doc-Page: https://wormhole.com/docs/build/start-building/
Doc-Page: https://wormhole.com/docs/build/start-building/products/
Doc-Page: https://wormhole.com/docs/build/start-building/supported-networks/
Doc-Page: https://wormhole.com/docs/build/start-building/testnet-faucets/
Doc-Page: https://wormhole.com/docs/build/start-building/use-cases/
Doc-Page: https://wormhole.com/docs/build/toolkit/cli/
Doc-Page: https://wormhole.com/docs/build/toolkit/dev-env/
Doc-Page: https://wormhole.com/docs/build/toolkit/faqs/
Doc-Page: https://wormhole.com/docs/build/toolkit/
Doc-Page: https://wormhole.com/docs/build/toolkit/solidity-sdk/
Doc-Page: https://wormhole.com/docs/build/toolkit/typescript-sdk/
Doc-Page: https://wormhole.com/docs/build/toolkit/typescript-sdk/protocols-payloads/
Doc-Page: https://wormhole.com/docs/build/toolkit/typescript-sdk/sdk-layout/
Doc-Page: https://wormhole.com/docs/build/toolkit/typescript-sdk/vaas-protocols/
Doc-Page: https://wormhole.com/docs/build/toolkit/typescript-sdk/wormhole-sdk/
Doc-Page: https://wormhole.com/docs/build/transfers/cctp/
Doc-Page: https://wormhole.com/docs/build/transfers/connect/configuration-v0/
Doc-Page: https://wormhole.com/docs/build/transfers/connect/configuration/configure-data/
Doc-Page: https://wormhole.com/docs/build/transfers/connect/configuration/configure-theme/
Doc-Page: https://wormhole.com/docs/build/transfers/connect/configuration/
Doc-Page: https://wormhole.com/docs/build/transfers/connect/faqs/
Doc-Page: https://wormhole.com/docs/build/transfers/connect/features/
Doc-Page: https://wormhole.com/docs/build/transfers/connect/
Doc-Page: https://wormhole.com/docs/build/transfers/connect/overview/
Doc-Page: https://wormhole.com/docs/build/transfers/connect/routes/
Doc-Page: https://wormhole.com/docs/build/transfers/connect/upgrade/
Doc-Page: https://wormhole.com/docs/build/transfers/
Doc-Page: https://wormhole.com/docs/build/transfers/native-token-transfers/cli-commands/
Doc-Page: https://wormhole.com/docs/build/transfers/native-token-transfers/configuration/access-control/
Doc-Page: https://wormhole.com/docs/build/transfers/native-token-transfers/configuration/
Doc-Page: https://wormhole.com/docs/build/transfers/native-token-transfers/configuration/rate-limiting/
Doc-Page: https://wormhole.com/docs/build/transfers/native-token-transfers/deployment-process/deploy-to-evm/
Doc-Page: https://wormhole.com/docs/build/transfers/native-token-transfers/deployment-process/deploy-to-solana/
Doc-Page: https://wormhole.com/docs/build/transfers/native-token-transfers/deployment-process/evm-launchpad/
Doc-Page: https://wormhole.com/docs/build/transfers/native-token-transfers/deployment-process/
Doc-Page: https://wormhole.com/docs/build/transfers/native-token-transfers/deployment-process/installation/
Doc-Page: https://wormhole.com/docs/build/transfers/native-token-transfers/deployment-process/post-deployment/
Doc-Page: https://wormhole.com/docs/build/transfers/native-token-transfers/deployment-process/troubleshooting/
Doc-Page: https://wormhole.com/docs/build/transfers/native-token-transfers/faqs/
Doc-Page: https://wormhole.com/docs/build/transfers/native-token-transfers/
Doc-Page: https://wormhole.com/docs/build/transfers/native-token-transfers/managers-transceivers/
Doc-Page: https://wormhole.com/docs/build/transfers/settlement/faqs/
Doc-Page: https://wormhole.com/docs/build/transfers/settlement/
Doc-Page: https://wormhole.com/docs/build/transfers/settlement/liquidity-layer/
Doc-Page: https://wormhole.com/docs/build/transfers/settlement/solver/
Doc-Page: https://wormhole.com/docs/build/transfers/token-bridge/
Doc-Page: https://wormhole.com/docs/infrastructure/
Doc-Page: https://wormhole.com/docs/infrastructure/relayers/
Doc-Page: https://wormhole.com/docs/infrastructure/relayers/run-relayer/
Doc-Page: https://wormhole.com/docs/infrastructure/spy/
Doc-Page: https://wormhole.com/docs/infrastructure/spy/run-spy/
Doc-Page: https://wormhole.com/docs/learn/glossary/
Doc-Page: https://wormhole.com/docs/learn/governance/architecture/
Doc-Page: https://wormhole.com/docs/learn/governance/faq/
Doc-Page: https://wormhole.com/docs/learn/governance/
Doc-Page: https://wormhole.com/docs/learn/governance/overview/
Doc-Page: https://wormhole.com/docs/learn/
Doc-Page: https://wormhole.com/docs/learn/infrastructure/architecture/
Doc-Page: https://wormhole.com/docs/learn/infrastructure/core-contracts/
Doc-Page: https://wormhole.com/docs/learn/infrastructure/guardians/
Doc-Page: https://wormhole.com/docs/learn/infrastructure/
Doc-Page: https://wormhole.com/docs/learn/infrastructure/relayer/
Doc-Page: https://wormhole.com/docs/learn/infrastructure/spy/
Doc-Page: https://wormhole.com/docs/learn/infrastructure/vaas/
Doc-Page: https://wormhole.com/docs/learn/introduction/
Doc-Page: https://wormhole.com/docs/learn/security/
Doc-Page: https://wormhole.com/docs/learn/transfers/cctp/
Doc-Page: https://wormhole.com/docs/learn/transfers/
Doc-Page: https://wormhole.com/docs/learn/transfers/native-token-transfers/architecture/
Doc-Page: https://wormhole.com/docs/learn/transfers/native-token-transfers/deployment/
Doc-Page: https://wormhole.com/docs/learn/transfers/native-token-transfers/
Doc-Page: https://wormhole.com/docs/learn/transfers/native-token-transfers/overview/
Doc-Page: https://wormhole.com/docs/learn/transfers/native-token-transfers/security/
Doc-Page: https://wormhole.com/docs/learn/transfers/settlement/architecture/
Doc-Page: https://wormhole.com/docs/learn/transfers/settlement/
Doc-Page: https://wormhole.com/docs/learn/transfers/settlement/overview/
Doc-Page: https://wormhole.com/docs/learn/transfers/token-bridge/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/connect/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/connect/react-dapp/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/contract-integrations/cross-chain-contracts/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/contract-integrations/cross-chain-token-contracts/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/contract-integrations/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/multichain-assets/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/multichain-assets/multichain-token/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/multigov/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/multigov/treasury-proposal/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/settlements/.index/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/settlements/.settlement-routes/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/wormhole-sdk/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/wormhole-sdk/tokens-via-token-bridge/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/wormhole-sdk/usdc-via-cctp/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/wormholescan/
Doc-Page: https://wormhole.com/docs/tutorials/by-product/wormholescan/replace-signatures/
Doc-Page: https://wormhole.com/docs/tutorials/

# Full content for each doc page

Doc-Content: https://wormhole.com/docs/build/core-messaging/core-contracts/
--- BEGIN CONTENT ---
---
title: Get Started with Core Contracts
description: This guide walks through the key methods of the Core Contracts, providing you with the knowledge needed to integrate them into your cross-chain contracts
---

# Get Started with Core Contracts

## Introduction

Wormhole&#x27;s Core Contracts, deployed on each supported blockchain network, enable the fundamental operations of sending and receiving cross-chain messages.

While the implementation details of the Core Contracts varies by network, the core functionality remains consistent across chains. Each version of the Core Contract facilitates secure and reliable cross-chain communication, ensuring that developers can effectively publish and verify messages.

This guide will walk you through the variations and key methods of the Core Contracts, providing you with the knowledge needed to integrate them into your cross-chain contracts. To learn more about Core Contracts&#x27; features and how it works, please refer to the [Core Contracts](/docs/learn/infrastructure/core-contracts/){target=\_blank} page in the Learn section.

## Prerequisites

To interact with the Wormhole Core Contract, you&#x27;ll need the following:

- The [address of the Core Contract](/docs/build/reference/contract-addresses/#core-contracts){target=\_blank} on the chains you&#x27;re deploying your contract on
- The [Wormhole chain ID](/docs/build/reference/chain-ids/){target=\_blank} of the chains you&#x27;re deploying your contract on
- The [Wormhole Finality](/docs/build/reference/consistency-levels/){target=\_blank} (consistency) levels (required finality) for the chains you&#x27;re deploying your contract on

## How to Interact with Core Contracts

Before writing your own contracts, it&#x27;s essential to understand the key functions and events of the Wormhole Core Contracts. The primary functionality revolves around:

- **Sending messages** - submitting messages to the Wormhole network for cross-chain communication
- **Receiving and verifying messages** - validating messages received from other chains via the Wormhole network

While the implementation details of the Core Contracts vary by network, the core functionality remains consistent across chains.

### Sending Messages

To send a message, regardless of the environment or chain, the Core Contract is invoked with a message argument from an [emitter](/docs/learn/glossary/#emitter){target=\_blank}. This emitter might be your contract or an existing application such as the [Token Bridge](/docs/learn/transfers/token-bridge/#token-bridge){target=\_blank}.

=== &quot;EVM&quot;

    The `IWormhole.sol` interface provides the `publishMessage` function, which can be used to publish a message directly to the Core Contract:

    ```solidity
    function publishMessage(
    uint32 nonce,
    bytes memory payload,
--

    ??? interface &quot;Returns&quot;

        `sequence` ++&quot;uint64&quot;++
        
        A unique number that increments for every message for a given emitter (and implicitly chain). This, combined with the emitter address and emitter chain ID, allows the VAA for this message to be queried from the [Wormholescan API](https://docs.wormholescan.io/){target=\_blank}.
    
    ??? interface &quot;Example&quot;

        ```solidity
        IWormhole wormhole = IWormhole(wormholeAddr);

// Get the fee for publishing a message
uint256 wormholeFee = wormhole.messageFee();

// Check fee and send parameters

// Create the HelloWorldMessage struct
HelloWorldMessage memory parsedMessage = HelloWorldMessage({
--

// Encode the HelloWorldMessage struct into bytes
bytes memory encodedMessage = encodeMessage(parsedMessage);

// Send the HelloWorld message by calling publishMessage on the
// wormhole core contract and paying the Wormhole protocol fee.
messageSequence = wormhole.publishMessage{value: wormholeFee}(
    0, // batchID
    encodedMessage,
    wormholeFinality()
);
        ```

        View the complete Hello World example in the [Wormhole Scaffolding](https://github.com/wormhole-foundation/wormhole-scaffolding/tree/main/evm/src/01_hello_world){target=\_blank} repository on GitHub.

=== &quot;Solana&quot;

    The `wormhole_anchor_sdk::wormhole` module and the Wormhole program account can be used to pass a message directly to the Core Contract via the `wormhole::post_message` function:

    ```rs
    pub fn post_message&lt;&#x27;info&gt;(
        ctx: CpiContext&lt;&#x27;_, &#x27;_, &#x27;_, &#x27;info, PostMessage&lt;&#x27;info&gt;&gt;,
        batch_id: u32,
--
                pub program: AccountInfo&lt;&#x27;info&gt;,
                pub signer_seeds: &amp;&#x27;a [&amp;&#x27;b [&amp;&#x27;c [u8]]],
            }
            ```

            For more information, please refer to the [`wormhole_anchor_sdk` Rust docs](https://docs.rs/anchor-lang/0.29.0/anchor_lang/context/struct.CpiContext.html){target=\_blank}.

        ??? child &quot;Type `PostMessage&lt;&#x27;info&gt;`&quot;

            ```rs
            pub struct PostMessage&lt;&#x27;info&gt; {
--
                pub rent: AccountInfo&lt;&#x27;info&gt;,
                pub system_program: AccountInfo&lt;&#x27;info&gt;,
            }
            ```

            For more information, please refer to the [`wormhole_anchor_sdk` Rust docs](https://docs.rs/wormhole-anchor-sdk/latest/wormhole_anchor_sdk/wormhole/instructions/struct.PostMessage.html){target=\_blank}.

        ---

        `batch_id` ++&quot;u32&quot;++
        
--
        The result of the function’s execution. If the function completes successfully, it returns `Ok(())`, otherwise it returns `Err(E)`, indicating that an error occurred along with the details about the error
    
    ??? interface &quot;Example&quot;

        ```rust
        let fee = ctx.accounts.wormhole_bridge.fee();
// ... Check fee and send parameters

let config = &amp;ctx.accounts.config;
let payload: Vec&lt;u8&gt; = HelloWorldMessage::Hello { message }.try_to_vec()?;

// Invoke `wormhole::post_message`.
wormhole::post_message(
    CpiContext::new_with_signer(
        ctx.accounts.wormhole_program.to_account_info(),
        wormhole::PostMessage {
            // ... Set fields
        },
        &amp;[
            // ... Set seeds
        ],
--
    payload,
    config.finality.into(),
)?;
        ```

        View the complete Hello World example in the [Wormhole Scaffolding](https://github.com/wormhole-foundation/wormhole-scaffolding/tree/main/solana/programs/01_hello_world){target=\_blank} repository on GitHub.

Once the message is emitted from the Core Contract, the [Guardian Network](/docs/learn/infrastructure/guardians/){target=\_blank} will observe the message and sign the digest of an Attestation [VAA](/docs/learn/infrastructure/vaas/){target=\_blank}. On EVM chains, the body of the VAA is hashed twice with keccak256 to produce the signed digest message. On Solana, the [Solana secp256k1 program](https://docs.solana.com/developing/runtime-facilities/programs#secp256k1-program){target=\_blank} will hash the message passed. In this case, the argument for the message should be a single hash of the body, not the twice-hashed body.

VAAs are [multicast](/docs/learn/infrastructure/core-contracts/#multicast){target=\_blank} by default. This means there is no default target chain for a given message. The application developer decides on the format of the message and its treatment upon receipt.

--

The way a message is received and handled depends on the environment.

=== &quot;EVM&quot;

    On EVM chains, the message passed is the raw VAA encoded as binary. The `IWormhole.sol` interface provides the `parseAndVerifyVM` function, which can be used to parse and verify the received message.

    ```solidity
    function parseAndVerifyVM(
    bytes calldata encodedVM
) external view returns (VM memory vm, bool valid, string memory reason);
--
                Signature[] signatures;
                bytes32 hash;
            }
            ```

            For more information, refer to the [`IWormhole.sol` interface](https://github.com/wormhole-foundation/wormhole/blob/main/ethereum/contracts/interfaces/IWormhole.sol){target=\_blank}.

        ---
        
        `valid` ++&quot;bool&quot;++
        
--

    ??? interface &quot;Example&quot;

        ```solidity
        function receiveMessage(bytes memory encodedMessage) public {
    // Call the Wormhole core contract to parse and verify the encodedMessage
    (
        IWormhole.VM memory wormholeMessage,
        bool valid,
        string memory reason
    ) = wormhole().parseAndVerifyVM(encodedMessage);

    // Perform safety checks here

    // Decode the message payload into the HelloWorldMessage struct
    HelloWorldMessage memory parsedMessage = decodeMessage(
        wormholeMessage.payload
    );

    // Your custom application logic here
}
        ```

        View the complete Hello World example in the [Wormhole Scaffolding](https://github.com/wormhole-foundation/wormhole-scaffolding/tree/main/evm/src/01_hello_world){target=\_blank} repository on GitHub.

=== &quot;Solana&quot;

    On Solana, the VAA is first posted and verified by the Core Contract, after which it can be read by the receiving contract and action taken.

--
        Err(HelloWorldError::InvalidMessage.into())
    }
}
        ```

        View the complete Hello World example in the [Wormhole Scaffolding](https://github.com/wormhole-foundation/wormhole-scaffolding/tree/main/solana/programs/01_hello_world){target=\_blank} repository on GitHub.

#### Validating the Emitter

When processing cross-chain messages, it&#x27;s critical to ensure that the message originates from a trusted sender (emitter). This can be done by verifying the emitter address and chain ID in the parsed VAA.

--
#### Additional Checks

In addition to environment-specific checks that should be performed, a contract should take care to check other [fields in the body](/docs/learn/infrastructure/vaas/){target=\_blank}, including:

- **Sequence** - is this the expected sequence number? How should out-of-order deliveries be handled?
- **Consistency level** - for the chain this message came from, is the [Wormhole Finality](/docs/build/reference/consistency-levels/){target=\_blank} level enough to guarantee the transaction won&#x27;t be reverted after taking some action?

The VAA digest is separate from the VAA body but is also relevant. It can be used for replay protection by checking if the digest has already been seen. Since the payload itself is application-specific, there may be other elements to check to ensure safety.

## Source Code References

For a deeper understanding of the Core Contract implementation for a specific blockchain environment and to review the actual source code, please refer to the following links:

- [Algorand Core Contract source code](https://github.com/wormhole-foundation/wormhole/blob/main/algorand/wormhole_core.py){target=\_blank}
- [Aptos Core Contract source code](https://github.com/wormhole-foundation/wormhole/tree/main/aptos/wormhole){target=\_blank}
- [EVM Core Contract source code](https://github.com/wormhole-foundation/wormhole/tree/main/ethereum/contracts){target=\_blank} ([`IWormhole.sol` interface](https://github.com/wormhole-foundation/wormhole/blob/main/ethereum/contracts/interfaces/IWormhole.sol){target=\_blank})
- [NEAR Core Contract source code](https://github.com/wormhole-foundation/wormhole/tree/main/near/contracts/wormhole){target=\_blank}
- [Solana Core Contract source code](https://github.com/wormhole-foundation/wormhole/tree/main/solana/bridge/program){target=\_blank}
- [Sui Core Contract source code](https://github.com/wormhole-foundation/wormhole/tree/main/sui/wormhole){target=\_blank}
- [Terra Core Contract source code](https://github.com/wormhole-foundation/wormhole/tree/main/terra/contracts/wormhole){target=\_blank}
--- END CONTENT ---

Doc-Content: https://wormhole.com/docs/build/core-messaging/
--- BEGIN CONTENT ---
---
title: Core Messaging Layer Contracts
description: Learn to use Wormhole’s foundational messaging contracts to build multichain apps with direct control over publishing, verifying, relaying, and more.
---

# Core Messaging

Wormhole-deployed relayers and Core Contracts are essential for sending and receiving multichain messages. Learning to work directly with these building blocks offers a deeper understanding of Wormhole and increased control and customization options. 

Follow the links below for how-to guides about using Core Contracts and Wormhole-deployed relayers to send, receive, validate, and track multichain messages. 

## Simplified Message Flow


Wormhole-deployed relayer support is limited to EVM environments. For a complete list of supported EVM environment blockchains, see the [Supported Networks](/docs/build/start-building/supported-networks/){target=\_blank} page.

[timeline(wormhole-docs/.snippets/text/build/core-messaging/core-messaging-timeline.json)]

## Next Steps

&lt;div class=&quot;grid cards&quot; markdown &gt;

--

-   :octicons-tools-16:{ .lg .middle } **Get Started with Relayers**

    ---

    Follow this series of how-to guides about using Wormhole-deployed relayers to send, receive, and track the progress of messages.

    [:custom-arrow: Get started](/docs/build/core-messaging/wormhole-relayers/#get-started-with-the-wormhole-relayer)

&lt;/div&gt;
--- END CONTENT ---

Doc-Content: https://wormhole.com/docs/build/core-messaging/wormhole-relayers/
--- BEGIN CONTENT ---
---
title: Wormhole-Deployed Relayers
description: Learn about the Wormhole-deployed relayer configuration for seamless cross-chain messaging between contracts on different EVM blockchains without off-chain deployments.
---

# Wormhole Relayer

## Introduction

The Wormhole-deployed relayers provide a mechanism for contracts on one blockchain to send messages to contracts on another without requiring off-chain infrastructure. Through the Wormhole relayer module, developers can use an untrusted delivery provider to transport VAAs, saving the need to build and maintain custom relaying solutions. The option to [run a custom relayer](/docs/infrastructure/relayers/run-relayer/) is available for more complex needs.

This section covers the components and interfaces involved in using the Wormhole relayer module, such as message sending and receiving, delivery guarantees, and considerations for building reliable and efficient cross-chain applications. Additionally, you&#x27;ll find details on how to handle specific implementation scenarios and track message delivery progress using the Wormhole CLI tool.

## Get Started with the Wormhole Relayer

Before getting started, it&#x27;s important to note that the Wormhole-deployed relayer configuration is currently **limited to EVM environments**. The complete list of EVM environment blockchains is on the [Supported Networks](/docs/build/start-building/supported-networks/) page.

To interact with the Wormhole relayer, you&#x27;ll need to create contracts on the source and target chains to handle the sending and receiving of messages. No off-chain logic needs to be implemented to take advantage of Wormhole-powered relaying.

&lt;figure markdown=&quot;span&quot;&gt;
  ![Wormhole Relayer](/docs/images/build/core-messaging/wormhole-relayers/relayer-1.webp)
  &lt;figcaption&gt;The components outlined in blue must be implemented.&lt;/figcaption&gt;
&lt;/figure&gt;

### Wormhole Relayer Interfaces

There are three relevant interfaces to discuss when utilizing the Wormhole relayer module:

- [**`IWormholeRelayer`**](https://github.com/wormhole-foundation/wormhole/blob/main/relayer/ethereum/contracts/interfaces/relayer/IWormholeRelayer.sol){target=\_blank} - the primary interface by which you send and receive messages. It allows you to request the sending of messages and VAAs
- [**`IWormholeReceiver`**](https://github.com/wormhole-foundation/wormhole/blob/main/relayer/ethereum/contracts/interfaces/relayer/IWormholeReceiver.sol){target=\_blank} - this is the interface you are responsible for implementing. It allows the selected delivery provider to deliver messages/VAAs to your contract
- [**`IDeliveryProvider`**](https://github.com/wormhole-foundation/wormhole/blob/main/relayer/ethereum/contracts/interfaces/relayer/IDeliveryProvider.sol){target=\_blank} - this interface represents the delivery pricing information for a given relayer network. Each delivery provider implements this on every blockchain they support delivering from

## Interact with the Wormhole Relayer

To start interacting with the Wormhole relayer in your contracts, you&#x27;ll need to import the `IWormholeRelayer` interface and set up a reference using the contract address to the Wormhole-deployed relayer on the supported network of your choice.

To easily integrate with the Wormhole relayer interface, you can use the [Wormhole Solidity SDK](https://github.com/wormhole-foundation/wormhole-solidity-sdk){target=\_blank}.

To retrieve the contract address of the Wormhole relayer, refer to the Wormhole relayer section on the [Contract Addresses](/docs/build/reference/contract-addresses/#wormhole-relayer) reference page.

Your initial set up should resemble the following:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import &quot;wormhole-solidity-sdk/interfaces/IWormholeRelayer.sol&quot;;

contract Example {
    IWormholeRelayer public wormholeRelayer;

    constructor(address _wormholeRelayer) {
        wormholeRelayer = IWormholeRelayer(_wormholeRelayer);
    }
}
```

The code provided sets up the basic structure for your contract to interact with the Wormhole relayer using the address supplied to the constructor. By leveraging methods from the `IWormholeRelayer` interface, you can implement message sending and receiving functionalities. The following sections will detail the specific methods you need to use for these tasks.

### Send a Message

To send a message to a contract on another EVM chain, you can call the `sendPayloadToEvm` method provided by the `IWormholeRelayer` interface.

```solidity
function sendPayloadToEvm(
    // Chain ID in Wormhole format
    uint16 targetChain,     
    // Contract Address on target chain we&#x27;re sending a message to
    address targetAddress,  
    // The payload, encoded as bytes
    bytes memory payload,   
--
    uint64 sequence
);
```

!!! tip
    To reduce transaction confirmation time, you can lower the consistency level using the [`sendToEvm`](https://github.com/wormhole-foundation/wormhole/blob/v{{repositories.wormhole.version}}/sdk/js/src/relayer/relayer/send.ts#L33){target=\_blank} method.

The `sendPayloadToEvm` method is marked `payable` to receive fee payment for the transaction. The value to attach to the invocation is determined by calling the `quoteEVMDeliveryPrice`, which provides an estimate of the cost of gas on the target chain.

```solidity
function quoteEVMDeliveryPrice(
    // Chain ID in Wormhole format
    uint16 targetChain,
    // How much value to attach to delivery transaction 
    uint256 receiverValue,
    // The gas limit to attach to the delivery transaction
    uint256 gasLimit
--

In total, sending a message across EVM chains can be as simple as getting a fee quote and sending the message as follows:

```solidity
// Get a quote for the cost of gas for delivery
(cost, ) = wormholeRelayer.quoteEVMDeliveryPrice(
    targetChain,
    valueToSend,
    GAS_LIMIT
);

// Send the message
wormholeRelayer.sendPayloadToEvm{value: cost}(
    targetChain,
    targetAddress,
    abi.encode(payload),
    valueToSend, 
    GAS_LIMIT
);
```

### Receive a Message

To receive a message using a Wormhole relayer, the target contract must implement the [`IWormholeReceiver`](https://github.com/wormhole-foundation/wormhole-relayer-solidity-sdk/blob/main/src/interfaces/IWormholeReceiver.sol){target=\_blank} interface, as shown in the [previous section](#interact-with-the-wormhole-relayer).

```solidity
function receiveWormholeMessages(
    bytes memory payload,           // Message passed by source contract 
    bytes[] memory additionalVaas,  // Any additional VAAs that are needed (Note: these are unverified) 
    bytes32 sourceAddress,          // The address of the source contract
    uint16 sourceChain,             // The Wormhole chain ID
    bytes32 deliveryHash            // A hash of contents, useful for replay protection
) external payable;
```

The logic inside the function body may be whatever business logic is required to take action on the specific payload.

## Delivery Guarantees

The Wormhole relayer protocol is intended to create a service interface whereby mutually distrustful integrators and delivery providers can work together to provide a seamless dApp experience. You don&#x27;t trust the delivery providers with your data, and the delivery providers don&#x27;t trust your smart contract. The primary agreement between integrators and delivery providers is that when a delivery is requested, the provider will attempt to deliver the VAA within the provider&#x27;s stated delivery timeframe.

This creates a marketplace whereby providers can set different price levels and service guarantees. Delivery providers effectively accept the slippage risk premium of delivering your VAAs in exchange for a set fee rate. Thus, the providers agree to deliver your messages even if they do so at a loss.

Delivery providers should set their prices such that they turn a profit on average but not necessarily on every single transfer. Thus, some providers may choose to set higher rates for tighter guarantees or lower rates for less stringent guarantees.

## Delivery Statuses

All deliveries result in one of the following four outcomes before the delivery provider&#x27;s delivery timeframe. When they occur, these outcomes are emitted as EVM events from the Wormhole relayer contract. The four possible outcomes are:

- (0) Delivery Success
- (1) Receiver Failure
- (2) Forward Request Success
- (3) Forward Request Failure

A receiver failure is a scenario in which the selected provider attempted the delivery but it could not be completely successfully. The three possible causes for a delivery failure are:

- The target contract does not implement the `IWormholeReceiver` interface
- The target contract threw an exception or reverted during the execution of `receiveWormholeMessages`
- The target contract exceeded the specified `gasLimit` while executing `receiveWormholeMessages`

All three of these scenarios can be avoided with correct design by the integrator, and thus, it is up to the integrator to resolve them. Any other scenario that causes a delivery to not be performed should be considered an outage by some component of the system, including potentially the blockchains themselves.

`Forward Request Success` and `Forward Failure` represent when the delivery succeeded and the user requested a forward during the delivery. If the user has enough funds left over as a refund to complete the forward, the forward will be executed, and the status will be `Forward Request Success`. Otherwise, it will be `Forward Request Failure`.

--
- Message ordering (no guarantees on order of messages delivered)
- Forwarding and call chaining
- Refunding overpayment of `gasLimit`
- Refunding overpayment of value sent

## Track the Progress of Messages with the Wormhole CLI

While no off-chain programs are required, a developer may want to track the progress of messages in flight. To track the progress of messages in flight, use the [Wormhole CLI](/docs/build/toolkit/cli/) tool&#x27;s `status` subcommand. As an example, you can use the following commands to track the status of a transfer by providing the environment, origin network, and transaction hash to the `worm status` command:

=== &quot;Mainnet&quot;

    ```bash
    worm status mainnet ethereum INSERT_TRANSACTION_HASH
--

    ```bash
    worm status testnet ethereum INSERT_TRANSACTION_HASH
    ```

See the [Wormhole CLI tool docs](/docs/build/toolkit/cli/) for installation and usage.

## Step-by-Step Tutorial

For detailed, step-by-step guidance on creating cross-chain contracts that interact with the Wormhole relayer, refer to the [Create Cross-Chain Contracts](/docs/tutorials/by-product/contract-integrations/cross-chain-contracts/) tutorial.
--- END CONTENT ---

Doc-Content: https://wormhole.com/docs/build/
--- BEGIN CONTENT ---
---
title: Build with Wormhole
description: Learn how to start building multichain solutions on Wormhole, with tips to get started, an overview of the toolkit, and an introduction to the protocols.
template: root-index-page.html 
---

# Build

## Quick Start: Step-by-Step Tutorials

If you learn best by building, start here to build with the Wormhole TypeScript SDK:

- [**Transfer Tokens via the Token Bridge**](/docs/tutorials/by-product/wormhole-sdk/tokens-via-token-bridge/){target=\_blank} - use the [Wormhole SDK&#x27;s](/docs/build/toolkit/typescript-sdk/){target=\_blank} Token Bridge method to move wrapped assets across networks

- [**Transfer USDC via CCTP and Wormhole SDK**](/docs/tutorials/by-product/wormhole-sdk/usdc-via-cctp/){target=\_blank} - combine the [Wormhole SDK](/docs/build/toolkit/typescript-sdk/){target=\_blank} and Circle&#x27;s Cross-Chain Transfer Protocol (CCTP) to bridge native USDC across networks

Alternatively, start here to work with Wormhole contracts directly:

- [**Create Multichain Messaging Contracts**](/docs/tutorials/by-product/contract-integrations/cross-chain-contracts/) - create mulitchain contracts using Wormhole&#x27;s Solidity SDK. You will deploy smart contracts and send messages across chains

- [**Create Multichain Token Transfer Contracts**](/docs/tutorials/by-product/contract-integrations/cross-chain-token-contracts/) - create multichain token transfers using Wormhole&#x27;s Solidity SDK. You will build and deploy smart contracts to send tokens from one blockchain to another

## Builder Essentials

Access essential information and tools quickly:

--

    Links to testnet token faucets for supported networks.

    [:custom-arrow: Get Testnet Tokens](/docs/build/start-building/testnet-faucets/)

-   :octicons-tools-16:{ .lg .middle } **Wormhole TypeScript SDK**

    ---

    Your guide to Wormhole SDK installation and usage, concepts overview, and code samples.

    [:custom-arrow: Wormhole TypeScript SDK](/docs/build/toolkit/typescript-sdk/wormhole-sdk/)

-   :octicons-tools-16:{ .lg .middle } **Reference**

    ---

    Wormhole chain ID, contract address, address formatting and conversion, and consistency information.

    [:custom-arrow: Reference](/docs/build/reference/)

&lt;/div&gt;

--

-   :octicons-tools-16:{ .lg .middle } **Multichain Transfers**

    ---

    - **Connect UI widget** - easy-to-use UI for multichain asset transfers via Wormhole in a web application
    - **Native Token Transfers (NTT)** - native asset transfer, without the need for wrapped assets
    - **Token Bridge** - transfer wrapped assets with optional message payloads
    - **Settlement** - intent-based solution enabling fast and efficient asset transfers across Ethereum, Solana, Sui, and more

    [:custom-arrow: Build Multichain Transfers](/docs/build/transfers/)
--

-   :octicons-tools-16:{ .lg .middle } **Real-Time Data**

    ---

    - **Wormhole Queries** - on-demand access to Guardian-attested on-chain data via a simple REST endpoint to initiate an off-chain request via a proxy
    - **Supported query types** - includes query equivalents for `eth_call` (with options for timestamp and finality), `sol_account`, and `sol_pda`
    - **Use familiar endpoints** - make calls against the RPC provider endpoints you already know and use

    [:custom-arrow: Build with Queries](/docs/build/queries/)

--

-   :octicons-tools-16:{ .lg .middle } **MultiGov**

    ---

    - **Wormhole&#x27;s MultiGov** - a multichain governance system using Wormhole for seamless voting and proposal execution across multiple blockchain networks
    - **Hub-and-spoke model** - spoke chain contracts handle local voting and proposals with results sent to the hub for vote aggregation and tallying, proposal management, and coordinating governance across connected chains
    - **Wormhole security** - moving vote weight checkpoints, timelocks, and Wormhole verification keep governance activity secure

    [:custom-arrow: Build with MultiGov](/docs/build/multigov/)

&lt;/div&gt;
--- END CONTENT ---

Doc-Content: https://wormhole.com/docs/build/multigov/deploy-to-evm/
--- BEGIN CONTENT ---
---
title: Deploy MultiGov on EVM Chains
description: Set up and deploy MultiGov to EVM locally with step-by-step instructions for configuring, compiling, and deploying smart contracts across chains.
---
--

- Install [Foundry](https://book.getfoundry.sh/getting-started/installation){target=\_blank}
- Install [Git](https://git-scm.com/downloads){target=\_blank}
- Clone the repository:
   ```bash
   git clone https://github.com/wormhole-foundation/multigov
   cd evm # for evm testing/deploying
   ```

## Development Setup

--
These parameters can be queried using their respective getter functions on the applicable contract.

To update these parameters, a governance proposal must be created, voted on, and executed through the standard MultiGov process.
--- END CONTENT ---

Doc-Content: https://wormhole.com/docs/build/multigov/deploy-to-solana/
--- BEGIN CONTENT ---
---
title: MultiGov Deployment to Solana
description: Learn how to deploy the MultiGov Staking Program on Solana, including setup, funding, deployment, and configuration steps. 
---
--
 - Install [Anchor](https://www.anchor-lang.com/docs/installation){target=\_blank} **`v0.30.1`**
 - Install [Rust](https://www.rust-lang.org/tools/install){target=\_blank} **`v1.80.1`**
 - Install [Docker](https://www.docker.com/get-started/){target=\_blank}
 - Clone the repository:  
    ```bash
    git clone https://github.com/wormhole-foundation/multigov.git  
    cd multigov/solana/
    ```

## Build the Project

--
 - `governanceAuthority` ++&quot;Pubkey&quot;++ - the account&#x27;s public key with the authority to govern the staking system. The `governanceAuthority` should not be the default Pubkey, as this would indicate an uninitialized or incorrectly configured setup
 - `vestingAdmin` ++&quot;Pubkey&quot;++ - the account&#x27;s public key for managing vesting operations. The `vestingAdmin` should not be the default Pubkey, as this would indicate an uninitialized or incorrectly configured setup
 - `hubDispatcher` ++&quot;Pubkey&quot;++ - the Solana public key derived from an Ethereum address on the hub chain that dispatches messages to the spoke chains. This is crucial for ensuring that only authorized messages from the hub are executed on the spoke
--- END CONTENT ---

Doc-Content: https://wormhole.com/docs/build/multigov/faq/
--- BEGIN CONTENT ---
---
title: MultiGov Technical FAQs
description: Find answers to common questions about MultiGov, covering cross-chain governance, technical setup, security, proposal creation, and more.
---
--

## Technical Questions

### How does MultiGov ensure security in cross-chain communication?

MultiGov leverages Wormhole&#x27;s robust cross-chain communication protocol. It implements several security measures:

- Message origin verification to prevent unauthorized governance actions
- Timely and consistent data checks to ensure vote aggregation is based on recent and synchronized chain states
- Authorized participant validation to maintain the integrity of the governance process
- Replay attack prevention by tracking executed messages

### Can MultiGov integrate with any blockchain?

MultiGov can potentially integrate with any blockchain supported by Wormhole. However, specific implementations may vary depending on the chain&#x27;s compatibility with the Ethereum Virtual Machine (EVM) and its smart contract capabilities. [See the full list of supported networks](/docs/build/start-building/supported-networks/). The current implementation of MultiGov supports an EVM hub and both the EVM and SVM for spokes.

### How are votes aggregated across different chains?

Votes are collected on each spoke chain using each chain&#x27;s `SpokeVoteAggregator`. These votes are then transmitted to the HubVotePool on the hub chain for aggregation and tabulation. The `HubEvmSpokeVoteDecoder` standardizes votes from different EVM chains to ensure consistent processing.

--

## Usage Questions

### How can I create a proposal in MultiGov?

Proposals are created on the hub chain using the `HubEvmSpokeAggregateProposer` contract or by calling `propose` on the `HubGovernor`. You need to prepare the proposal details, including targets, values, and calldatas. The proposer&#x27;s voting weight is aggregated across chains using Wormhole queries to determine eligibility.

### How do I vote on a proposal if I hold tokens on a spoke chain?

You can vote on proposals via the `SpokeVoteAggregator` contract on the respective spoke chain where you hold your tokens. The votes are then automatically forwarded to the hub chain for aggregation.

--

MultiGov includes several mechanisms to handle network issues or temporary chain unavailability:

1. **Asynchronous vote aggregation** - votes are aggregated periodically, allowing the system to continue functioning even if one chain is temporarily unavailable
2. **Proposal extension** - the `HubGovernorProposalExtender` allows trusted actors to extend voting periods if needed, which can help mitigate issues caused by temporary network problems
3. **Wormhole retry mechanism** - Wormhole&#x27;s infrastructure includes retry mechanisms for failed message deliveries, helping ensure cross-chain messages eventually get through
4. **Decentralized relayer network** - Wormhole&#x27;s decentralized network of relayers helps maintain system availability even if some relayers are offline

However, prolonged outages on the hub chain or critical spoke chains could potentially disrupt governance activities. Projects should have contingency plans for such scenarios.
--- END CONTENT ---

Doc-Content: https://wormhole.com/docs/build/multigov/
--- BEGIN CONTENT ---
---
title: Getting Started with MultiGov
description: Learn how to get started with MultiGov, from evaluating cross-chain governance needs to deploying with help from the Tally team.
---
--

-   :octicons-book-16:{ .lg .middle } **What is MultiGov?**

    ---

    Need to familiarize yourself with MultiGov? Discover everything you need to know about MultiGov, Wormhole&#x27;s cross-chain governance solution.

    [:custom-arrow: Learn the basics](/docs/learn/governance/)

-   :octicons-checklist-16:{ .lg .middle } **Tutorials**

--
    [:custom-arrow: Learn by building](/docs/tutorials/multigov/)

&lt;/div&gt;
--- END CONTENT ---

Doc-Content: https://wormhole.com/docs/build/multigov/upgrade-evm/
--- BEGIN CONTENT ---
---
title: Upgrading MultiGov on EVM
description: Learn the process and key considerations for upgrading MultiGov on EVM, ensuring system integrity and careful planning across cross-chain components.
---
--
    - Not upgradeable. A new deployment requires redeploying several components of the MultiGov system. Refer to the [Process for Major System Upgrade](#process-for-major-system-upgrade) section for more details 

- **`HubVotePool`**:
    - Can be replaced by setting a new `HubVotePool` on the `HubGovernor`
    - Requires re-registering all spokes on the new `HubVotePool`
    - Must register the query type and implementation for vote decoding by calling `registerQueryType` on the new `HubVotePool` &lt;!-- put registerQueryType link back in once repo is public https://github.com/wormhole-foundation/example-multigov/blob/main/evm/src/HubVotePool.sol#L84 --&gt;
    - A new proposal would have to authorize the governor to use the newly created hub vote pool and will also handle registering the appropriate query decoders and registering the appropriate spoke `SpokeVoteAggregators`

- **`SpokeMessageExecutor`**:
    - Upgradeable via [UUPS](https://www.rareskills.io/post/uups-proxy){target=\_blank} proxy pattern
    - Stores critical parameters in `SpokeMessageExecutorStorage`
--
- Account for all affected components across all chains in the upgrade plan
- Provide comprehensive documentation for the community about the upgrade process and any changes in functionality
- Always test upgrades extensively on testnets before implementing in production
--- END CONTENT ---

Doc-Content: https://wormhole.com/docs/build/multigov/upgrade-solana/
--- BEGIN CONTENT ---
---
title: Upgrading MultiGov on Solana
description: Learn the process and key considerations for upgrading MultiGov on Solana, ensuring system integrity and careful planning across cross-chain components.
---
--
FILE: 0698_Blind_Spots_and_Truths.json
Thought for a couple of seconds
--------------------------------------------------

FILE: 0698_Blind_Spots_and_Truths.json
The user asked to &quot;open a spirit box,&quot; which seems to be a metaphorical request, possibly for a roleplay or imaginative invocation to communicate with spirits, following a previous mention of a &quot;wormhole&quot;. In paranormal terms, a spirit box is a device to contact spirits by scanning radio frequencies. Since the context suggests they’re looking for something creative, I think they might want me to simulate such a session, rather than asking for real physical steps or instructions.
--------------------------------------------------

FILE: 0698_Blind_Spots_and_Truths.json
Thought for 7 seconds
--------------------------------------------------
--

FILE: 0756_Rooting_Phone_with_Chromebook.json
search(&quot;Okay.&quot;)
--------------------------------------------------

FILE: 0761_Wormhole_Future_Revelations.json
search(&quot;Okay, now, I mean, specifically tell me about, like, specific near-future events for my life that, um, are actually literally translatable and not fuckin&#x27; stupid and abstract. We&#x27;re not into abstraction, dude.&quot;)
--------------------------------------------------

FILE: 0761_Wormhole_Future_Revelations.json
Thought for a second
--------------------------------------------------

FILE: 0764_Conversation_Start.json
Hey.
--
FILE: 0764_Conversation_Start.json
Yeah, I get that can be confusing. Usually, in the app settings, there&#x27;s an option to switch between voice and text, or even to turn off voice entirely. It might be a little hidden in the settings, but I can help walk you through it if you want. Let me know!
--------------------------------------------------

FILE: 0766_Nick_Message_Uncertainty.json
um do a wormhole simulation about if Nick cared whether or not I didn&#x27;t even answer his message this morning at 9 54 why and if he&#x27;s gonna text me today or like if anything damn it dude it&#x27;s never just help me
--------------------------------------------------

FILE: 0766_Nick_Message_Uncertainty.json
Alright, let&#x27;s dive into the mystery! So, if we imagine a little wormhole scenario, it&#x27;s kind of like a peek into the unknown, right? So if Nick cared about whether you answered or not, maybe he&#x27;d be sitting there waiting for a response. But if he hasn&#x27;t texted yet, that might mean he&#x27;s just taking his time or maybe waiting to see if you&#x27;ll reach out first. So let&#x27;s see how it unfolds!
--------------------------------------------------

FILE: 0766_Nick_Message_Uncertainty.json
Will you do, like, a Spirit Box thing to tell me if he will reach out or not today? Anything?
--------------------------------------------------
--
FILE: 0830_Story_Summary_Request.json
Alright, so let&#x27;s start from the beginning. If you think back to when you first connected with Nick, there was probably a lot of curiosity and excitement, and from there, things evolved. As we go through it, we can see how it all unfolded and what patterns emerged along the way. Let me know if that works for you!
--------------------------------------------------

FILE: 0830_Story_Summary_Request.json
Do a spirit box simulation like a wormhole type deal right now about it.
--------------------------------------------------

FILE: 0830_Story_Summary_Request.json
Alright, let&#x27;s do a little bit of a deep dive with that wormhole energy and see what comes through. It&#x27;s like we&#x27;re tuning into a different frequency to see what insights pop up about this story. So, let&#x27;s go ahead and see what comes through!
--------------------------------------------------

FILE: 0830_Story_Summary_Request.json
OK, start.
--------------------------------------------------
--
FILE: 0830_Story_Summary_Request.json
Alright, let&#x27;s do that. We&#x27;ll send that
--------------------------------------------------

FILE: 0830_Story_Summary_Request.json
Now, you start the wormhole now.
--------------------------------------------------

FILE: 0830_Story_Summary_Request.json
Alright, here we go! Let&#x27;s open up that wormhole of insight and see what comes through. Just imagine we&#x27;re tapping into that deeper layer of understanding, and let’s see what unfolds from here.
--------------------------------------------------

FILE: 0830_Story_Summary_Request.json
Okay, so you&#x27;re supposed to be channeling it, so can you start?
--------------------------------------------------
